# Selenium NUnit C# Automation Framework

- This **customizable framework** leverages free and open-source technologies such as Selenium WebDriver, NUnit, and ExtentReports to provide a complete test automation lifecycle—from global setup and WebDriver initialization in `BaseClass/BaseTest.cs`, through environment and test data loading via `Config/` and `Data/`, executing tests organized in `Tests/` with Page Object Model abstractions in `PageObjects/`, to detailed logging and rich report generation managed by a singleton `Utils/ExtentReportManager.cs` with ExtentReports saved in `Reports/`. Screenshots are automatically captured on test failures in `Screenshots/`, making this framework robust, maintainable, scalable, and easy to customize for any new project.
---

## 🚀 Features

- ✅ **Selenium WebDriver + NUnit Integration** with clear modular structure  
- 🧱 **BaseTest setup** centralized in `BaseClass/BaseTest.cs` for global setup, teardown, and WebDriver initialization  
- 🌐 **Config-driven environment profiles** managed by `Config/ConfigReader.cs` loading `Config/TestConfig.json`  
- 📊 **Test data handling** through `Data/TestDataReader.cs` reading JSON data from `Data/TestData.json`  
- 📝 **Page Object Model** implementation under `PageObjects/` for reusable UI element abstractions  
- 🔁 **BC.Selenium.WebUI Wrapper (v0.0.2-alpha)** providing detailed logging and explicit wait-enabled Selenium wrappers for more reliable actions  
- 🔁 **Reusable utilities** with detailed logging using `Utils/ExtentReportManager.cs`  
- 📸 **Automatic screenshot capture** on test failures saved to `Screenshots/` folder  
- 📋 **Organized test cases** inside `Tests/` directory including examples like `LoginTest.cs` and `PersonalDetailsTest.cs`  
- 📑 **Detailed HTML reports** generated by ExtentReports in `Reports/` folder (`AutomationReport_*.html`)  
- 🔍 Emphasis on clean, maintainable, and easy-to-read test automation code  

---

## 📂 Folder Structure Overview

---

## 🛠 Project Structure
```
├── BaseClass/
│ └── BaseTest.cs # Global setup, teardown, and WebDriver init
│
├── Config/
│ ├── ConfigReader.cs # Loads config based on active environment
│ └── TestConfig.json # Environment & browser settings
│
├── Data/
│ ├── TestDataReader.cs # Loads test data JSON
│ └── TestData.json
│
├── Examples/
│
├── PageObjects/
│
├── Reports/
│ └── AutomationReport_*.html # ExtentReports HTML reports
│
├── Screenshots/ # Screenshots saved on test failure
│
├── Tests/
│ ├── LoginTest.cs
│ ├── OtherDetailsTest.cs
│ ├── PersonalDetailsTest.cs
│ └── ZTemp.cs
│
├── Utils/
│ └── ExtentReportManager.cs # Singleton ExtentReports manager

```
## 🔠 Naming Conventions

| Element          | Convention    | Example               |
|------------------|---------------|-----------------------|
| File Name        | PascalCase.cs | `LoginTest.cs`        |
| Folder Name      | PascalCase    | `PageObjects`         |
| Class Name       | PascalCase   | `AuthService`         |
| Method Name      | PascalCase   | `GetUserInfo()`       |
| Variable Name    | camelCase    | `userEmail`           |
| Property Name    | PascalCase   | `UserEmail`           |
| Constant Name    | PascalCase   | `MaxRetries`          |
| Boolean Name     | camelCase    | `isLoggedIn`          |
| Test Method Name | PascalCase   | `ShouldLoginSuccessfully()` |



## ⚙️ Configuration

### TestConfig.json

```json
{
  "Environment": "QA",
  "Browser": "chrome",
  "BaseUrl": "https://opensource-demo.orangehrmlive.com/web/index.php/auth/login",
  "UserName": "Admin",
  "Password": "admin123"
}

```

## 🗃️ Test Data

- `Data/TestData.json` stores structured test data in JSON format, enabling data-driven testing  
- `Data/TestDataReader.cs` reads and parses this JSON data for use across multiple test cases  
- Separating test data from test logic improves maintainability and allows easy updates without code changes  
- Supports running tests with different input sets by simply modifying the JSON file  


## 💡 Examples
The `Examples/` folder contains a comprehensive set of ready-to-run raw demo test cases demonstrating various Selenium actions using C#. These tests cover common workflows and UI interactions to help you get started quickly and understand practical usage of the each selenium actions.


## 📐 Page Object Pattern

The **Page Object Model (POM)** design pattern helps keep your test code clean and maintainable by separating page-specific UI interactions into dedicated classes under `PageObjects/`.  
Each page class encapsulates element locators and actions, enabling reusable, readable, and easy-to-update test scripts. This reduces duplication and improves test stability.  
> **❌ Note on PageFactory and `@FindBy`:**  
> While PageFactory with `@FindBy` annotations was popular for element initialization, it has known drawbacks:  
> - ⚠️ **Stale element references** can occur if the page reloads or elements change dynamically  
> - 🐢 Can introduce **performance overhead** due to proxy creation and lazy loading  
> - 🔧 Debugging issues can be harder when locators fail silently  
> - 📉 Less flexible for dynamic element handling compared to explicit waits or direct `FindElement` calls  
>
> Because of these issues, many prefer explicit element locating within methods combined with robust **explicit waits** (like those in the BC.Selenium.WebUI wrapper) instead of PageFactory.

Example benefits of the POM approach (without PageFactory):  
 **✅ Key benefits of the POM approach:**  
- 🧩 **Clear separation** of page structure and test logic for better readability  
- 🔄 **Reusable and maintainable** page methods to avoid duplication  
- 🛠️ **Enhanced control** over element locating and wait strategies for improved stability  
- 🧩 **Encapsulation** of UI elements and behaviors within page classes  
- 🔄 **Reusability** across multiple tests promoting DRY principles  
- 🛠️ **Simplified maintenance** when UI changes occur, minimizing test breakage  

## 📸 Screenshot on Failure
- Screenshots are saved under `/Screenshots/` with a timestamped filename.
- Automatically captured during `[TearDown]` if test fails.

## ▶️ Running Tests
You can run the tests using Visual Studio Test Explorer or via CLI:
```bash
dotnet test --filter "FullyQualifiedName~Tests"
```
- This runs tests in the Tests folder.
- You can also override config via environment variables or by editing TestConfig.json


### 📊 Reports

- Detailed HTML reports generated using **ExtentReports**, saved in the `Reports/` folder as `AutomationReport_*.html`  
- 📋 Comprehensive test execution summaries with pass/fail status and logs  
- 📸 Screenshots captured on test failures are linked within reports for easy debugging  
- 🧾 Facilitates quick insights into test suite health and detailed results analysis  


### 🛠️ Utils

- Contains utility classes and helpers to support test execution and reporting  
- `Utils/ExtentReportManager.cs` manages the **ExtentReports** lifecycle as a singleton, ensuring consistent and thread-safe report generation  
- Facilitates detailed logging, test categorization, and report customization  
- Helps keep test code clean by centralizing common reusable functions and setup tasks  

## 📦 NuGet Packages Used
- AutoltX.Dotnet (3.3.14.5)
- BC.WeblJlWrapper (0.0.2-alpha)
- DotNetSeleniumExtras.WaitHelpers (3.11.0)
- ExtentReports (5.0.4)
- Microsoft.NET.Test.Sdk (17.14.1)
- Microsoft.Office.lnterop.Excel (15.0.4795.1001)
- Newtonsoft.Json (13.0.3)
- NUnit (4.3.2)
- NUnit3TestAdapter (5.0.0)
- Selenium.Support (4.34.0)
- Selenium.WebDriver (4.34.0)
- WebDriverManager (2.17.6)

## 👥 Author
Bijay Chhetri
🔗 github.com/bija510

## 📄 License
This project is licensed under the [MIT License](LICENSE).

