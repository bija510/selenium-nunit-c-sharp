# Selenium NUnit C# Automation Framework

- This **customizable framework** leverages free and open-source technologies such as Selenium WebDriver, NUnit, and ExtentReports to provide a complete test automation lifecycleâ€”from global setup and WebDriver initialization in `BaseClass/BaseTest.cs`, through environment and test data loading via `Config/` and `Data/`, executing tests organized in `Tests/` with Page Object Model abstractions in `PageObjects/`, to detailed logging and rich report generation managed by a singleton `Utils/ExtentReportManager.cs` with ExtentReports saved in `Reports/`. Screenshots are automatically captured on test failures in `Screenshots/`, making this framework robust, maintainable, scalable, and easy to customize for any new project.

## ğŸš€ Features

- âœ… **Selenium WebDriver + NUnit Integration** with clear modular structure  
- ğŸ§± **BaseTest setup** centralized in `BaseClass/BaseTest.cs` for global setup, teardown, and WebDriver initialization  
- ğŸŒ **Config-driven environment profiles** managed by `Config/ConfigReader.cs` loading `Config/TestConfig.json`  
- ğŸ“Š **Test data handling** through `Data/TestDataReader.cs` reading JSON data from `Data/TestData.json`  
- ğŸ“ **Page Object Model** implementation under `PageObjects/` for reusable UI element abstractions  
- ğŸ” **BC.Selenium.WebUI Wrapper (v0.0.2-alpha)** providing detailed logging and explicit wait-enabled Selenium wrappers for more reliable actions  
- ğŸ” **Reusable utilities** with detailed logging using `Utils/ExtentReportManager.cs`  
- ğŸ“¸ **Automatic screenshot capture** on test failures saved to `Screenshots/` folder  
- ğŸ“‹ **Organized test cases** inside `Tests/` directory including examples like `LoginTest.cs` and `PersonalDetailsTest.cs`  
- ğŸ“‘ **Detailed HTML reports** generated by ExtentReports in `Reports/` folder (`AutomationReport_*.html`)  
- ğŸ” Emphasis on clean, maintainable, and easy-to-read test automation code  


## ğŸ“‚ Folder Structure Overview

### ğŸ›  Project Structure
```
â”œâ”€â”€ BaseClass/
â”‚ â””â”€â”€ BaseTest.cs # Global setup, teardown, and WebDriver init
â”‚
â”œâ”€â”€ Config/
â”‚ â”œâ”€â”€ ConfigReader.cs # Loads config based on active environment
â”‚ â””â”€â”€ TestConfig.json # Environment & browser settings
â”‚
â”œâ”€â”€ Data/
â”‚ â”œâ”€â”€ TestDataReader.cs # Loads test data JSON
â”‚ â””â”€â”€ TestData.json
â”‚
â”œâ”€â”€ Examples/
â”‚
â”œâ”€â”€ PageObjects/
â”‚
â”œâ”€â”€ Reports/
â”‚ â””â”€â”€ AutomationReport_*.html # ExtentReports HTML reports
â”‚
â”œâ”€â”€ Screenshots/ # Screenshots saved on test failure
â”‚
â”œâ”€â”€ Tests/
â”‚ â”œâ”€â”€ LoginTest.cs
â”‚ â”œâ”€â”€ OtherDetailsTest.cs
â”‚ â”œâ”€â”€ PersonalDetailsTest.cs
â”‚ â””â”€â”€ ZTemp.cs
â”‚
â”œâ”€â”€ Utils/
â”‚ â””â”€â”€ ExtentReportManager.cs # Singleton ExtentReports manager

```
## ğŸ”  Naming Conventions

| Element          | Convention    | Example               |
|------------------|---------------|-----------------------|
| File Name        | PascalCase.cs | `LoginTest.cs`        |
| Folder Name      | PascalCase    | `PageObjects`         |
| Class Name       | PascalCase   | `AuthService`         |
| Method Name      | PascalCase   | `GetUserInfo()`       |
| Variable Name    | camelCase    | `userEmail`           |
| Property Name    | PascalCase   | `UserEmail`           |
| Constant Name    | PascalCase   | `MaxRetries`          |
| Boolean Name     | camelCase    | `isLoggedIn`          |
| Test Method Name | PascalCase   | `ShouldLoginSuccessfully()` |



## âš™ï¸ Configuration

### TestConfig.json

```json
{
  "Environment": "QA",
  "Browser": "chrome",
  "BaseUrl": "https://opensource-demo.orangehrmlive.com/web/index.php/auth/login",
  "UserName": "Admin",
  "Password": "admin123"
}

```

## ğŸ—ƒï¸ Test Data

- `Data/TestData.json` stores structured test data in JSON format, enabling data-driven testing  
- `Data/TestDataReader.cs` reads and parses this JSON data for use across multiple test cases  
- Separating test data from test logic improves maintainability and allows easy updates without code changes  
- Supports running tests with different input sets by simply modifying the JSON file  


## ğŸ’¡ Examples
The `Examples/` folder contains a comprehensive set of ready-to-run raw demo test cases demonstrating various Selenium actions using C#. These tests cover common workflows and UI interactions to help you get started quickly and understand practical usage of the each selenium actions.


## ğŸ“ Page Object Pattern

The **Page Object Model (POM)** design pattern helps keep your test code clean and maintainable by separating page-specific UI interactions into dedicated classes under `PageObjects/`.  
Each page class encapsulates element locators and actions, enabling reusable, readable, and easy-to-update test scripts. This reduces duplication and improves test stability.  

> ğŸ›‘ Deprecated in 3.11 (Nov 2017)  **âŒ Note on PageFactory and `@FindBy`:** 
> While PageFactory with `@FindBy` annotations was popular for element initialization, it has known drawbacks:  
> - âš ï¸ **Stale element references** can occur if the page reloads or elements change dynamically  
> - ğŸ¢ Can introduce **performance overhead** due to proxy creation and lazy loading  
> - ğŸ”§ Debugging issues can be harder when locators fail silently  
> - ğŸ“‰ Less flexible for dynamic element handling compared to explicit waits or direct `FindElement` calls  
>
> Because of these issues, many prefer explicit element locating within methods combined with robust **explicit waits** (like those in the BC.Selenium.WebUI wrapper) instead of PageFactory.

Example benefits of the POM approach (without PageFactory):  
 **âœ… Key benefits of the POM approach:**  
- ğŸ§© **Clear separation** of page structure and test logic for better readability  
- ğŸ”„ **Reusable and maintainable** page methods to avoid duplication  
- ğŸ› ï¸ **Enhanced control** over element locating and wait strategies for improved stability  
- ğŸ§© **Encapsulation** of UI elements and behaviors within page classes  
- ğŸ”„ **Reusability** across multiple tests promoting DRY principles  
- ğŸ› ï¸ **Simplified maintenance** when UI changes occur, minimizing test breakage  

## ğŸ“¸ Screenshot on Failure
- Screenshots are saved under `/Screenshots/` with a timestamped filename.
- Automatically captured during `[TearDown]` if test fails.

## â–¶ï¸ Running Tests
You can run the tests using Visual Studio Test Explorer or via CLI:
```bash
dotnet test --filter "FullyQualifiedName~Tests"
```
- This runs tests in the Tests folder.
- You can also override config via environment variables or by editing TestConfig.json


## ğŸ“Š Reports

- ğŸ“‚ HTML reports generated using ExtentReports, saved in `Reports/ as Report_CHROME_QA_DateTimeStamp.html`.
- ğŸ“‹ Summary of test results with `pass/fail status, logs`, and linked failure `screenshots`.
- ğŸ–¥ï¸ Includes key system/environment details like User Name, .NET version, NUnit version, run time, Git branch, machine info, environment, tester, OS, and browser.
- ğŸš€ Reports are automatically `published to GitHub Pages` on the gh-pages branch after each CI runâ€”visit the site URL in `Settings â†’ Pages â†’ Visit site` to view the latest report live.
- ğŸ“¦ After each run, the HTML report is `also available as a downloadable` artifact named html-report in the GitHub Actions workflow.


## ğŸ› ï¸ Utils

- Contains utility classes and helpers to support test execution and reporting  
- `Utils/ExtentReportManager.cs` manages the **ExtentReports** lifecycle as a singleton, ensuring consistent and thread-safe report generation  
- Facilitates detailed logging, test categorization, and report customization  
- Helps keep test code clean by centralizing common reusable functions and setup tasks  

## âœï¸ğŸ“ Commit Message Conventions

To keep commit history clean, consistent, and easy to understand, please follow the **Conventional Commit** types below when writing commit messages.

## Common Commit Types

| Type     | When to Use                                                   |
|----------|---------------------------------------------------------------|
| **feat** | A new feature                                                 |
| **fix**  | A bug fix                                                    |
| **docs** | Documentation-only changes                                   |
| **style**| Code style changes (formatting, missing semi-colons, etc.) â€” no logic change |
| **refactor** | Code changes that neither fixes a bug nor adds a feature |
| **perf** | Performance improvements                                    |
| **test** | Adding or updating tests                                    |
| **chore**| Changes to build process, auxiliary tools, libraries, or maintenance (no production code) |

### Examples for Your Project

| Type     | Example Commit Message                                     |
|----------|------------------------------------------------------------|
| feat     | `feat(login): add remember me checkbox`                    |
| fix      | `fix(cart): correct item quantity calculation`             |
| docs     | `docs(readme): update installation instructions`           |
| style    | `style: fix indentation and spacing`                       |
| refactor | `refactor: simplify login validation logic`                |
| perf     | `perf: improve page load time by optimizing queries`       |
| test     | `test: add unit tests for order service`                    |
| chore    | `chore: add environment info to extent report`             |

### Guidance for This Project
- Use **`chore:`** for infrastructure, configuration, tooling, or housekeeping tasks (e.g., adding environment info to Extent reports).  
- Use **`docs:`** when updating documentation like README files.  
- Use **`feat:`** for adding new test cases or reporting features.  
- Use **`fix:`** to correct bugs in tests or automation code.  

### Git Commit Message Format
```
A. <type>(<scope>): <short summary>
        or
B. <type>: <short summary>
        or
C. <type>: <short summary>
- Detail 1
- Detail 2
- Detail 3
```

- **`<type>`**: One of the commit types listed above.  
- **`<scope>`**: The area of the codebase affected (optional but recommended).  
- **`<short summary>`**: A concise description of the change.  

> NOTE: Keeping commit messages consistent helps everyone understand the project history and makes generating changelogs and releases easier.


## ğŸ“¦ NuGet Packages Used
- AutoltX.Dotnet (3.3.14.5)
- BC.WeblJlWrapper (0.0.2-alpha)
- âš ï¸ DotNetSeleniumExtras.WaitHelpers (3.11.0) => `(Provides ExpectedConditions class for WebDriverWait, last updated 3/11/2018) Deprecated in 3.11 (Nov 2017)`
- âŒ DotNetSeleniumExtras.PageObjects (3.11.0) => `(provides PageFactory (@FindBy) for .NET last updated 3/11/2018) Deprecated in 3.11 (Nov 2017)`
- ExtentReports (5.0.4)
- Microsoft.NET.Test.Sdk (17.14.1)
- Microsoft.Office.lnterop.Excel (15.0.4795.1001)
- Newtonsoft.Json (13.0.3)
- NUnit (4.3.2)
- NUnit3TestAdapter (5.0.0)
- Selenium.Support (4.34.0) ()
- Selenium.WebDriver (4.34.0)
- WebDriverManager (2.17.6)

## Explicit Waiting Strategies
When automating with Selenium WebDriver in C#, waiting for elements or conditions is crucial for stable tests. There are `three common approaches` you might see or use, especially with Selenium 4.34.0:

### âŒ 1. Old (Obsolete) â€” `ExpectedConditions` from Selenium.Support (pre-4.x)

```csharp
// ğŸš« Deprecated and removed in Selenium 4.x â€” this code will NOT compile or run
WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10));
wait.Until(ExpectedConditions.ElementIsVisible(By.Id("username")));
```

### âš ï¸ 2. Usage with DotNetSeleniumExtras.WaitHelpers
- ğŸ•°ï¸ Old / Legacy â€” last release was in 2018
- âš ï¸ No longer actively maintained or supported by Selenium. Use alternatives for new projects.
- Minimal code change, requires NuGet using SeleniumExtras.WaitHelpers;
- Drop-in replacement, requires adding the DotNetSeleniumExtras.WaitHelpers NuGet package using SeleniumExtras.WaitHelpers;
```csharp
using SeleniumExtras.WaitHelpers; // Make sure to install DotNetSeleniumExtras.WaitHelpers
WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10));
IWebElement el = wait.Until(ExpectedConditions.ElementToBeClickable(By.Id("username")));
```

### âœ… 3. Usage with Pure Lambda (Built into Selenium.Support) â€” No Extra Packages Needed
 Best No external dependency â€” you stick to pure Selenium Lambda - Future-proof, no NuGet, more control
```csharp
WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10));
IWebElement el = wait.Until(d => {
    var element = d.FindElement(By.Id("username"));
    return (element.Displayed && element.Enabled) ? element : null;
});
```

## ğŸ‘¥ Author
Bijay Chhetri
ğŸ”— github.com/bija510

## ğŸ“„ License
This project is licensed under the [MIT License](LICENSE).

