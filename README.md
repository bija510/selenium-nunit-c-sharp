# Selenium NUnit C# Automation Framework

- This **customizable framework** leverages free and open-source technologies such as Selenium WebDriver, NUnit, and ExtentReports to provide a complete test automation lifecycle—from global setup and WebDriver initialization in `BaseClass/BaseTest.cs`, through environment and test data loading via `Config/` and `Data/`, executing tests organized in `Tests/` with Page Object Model abstractions in `PageObjects/`, to detailed logging and rich report generation managed by a singleton `Utils/ExtentReportManager.cs` with ExtentReports saved in `Reports/`. Screenshots are automatically captured on test failures in `Screenshots/`, making this framework robust, maintainable, scalable, and easy to customize for any new project.

## 🚀 Features

- ✅ **Selenium WebDriver + NUnit Integration** with clear modular structure  
- 🧱 **BaseTest setup** centralized in `BaseClass/BaseTest.cs` for global setup, teardown, and WebDriver initialization  
- 🌐 **Config-driven environment profiles** managed by `Config/ConfigReader.cs` loading `Config/TestConfig.json`  
- 📊 **Test data handling** through `Data/TestDataReader.cs` reading JSON data from `Data/TestData.json`  
- 📝 **Page Object Model** implementation under `PageObjects/` for reusable UI element abstractions  
- 🔁 **BC.Selenium.WebUI Wrapper (v0.0.2-alpha)** providing detailed logging and explicit wait-enabled Selenium wrappers for more reliable actions  
- 🔁 **Reusable utilities** with detailed logging using `Utils/ExtentReportManager.cs`  
- 📸 **Automatic screenshot capture** on test failures saved to `Screenshots/` folder  
- 📋 **Organized test cases** inside `Tests/` directory including examples like `LoginTest.cs` and `PersonalDetailsTest.cs`  
- 📑 **Detailed HTML reports** generated by ExtentReports in `Reports/` folder (`AutomationReport_*.html`)  
- 🔍 Emphasis on clean, maintainable, and easy-to-read test automation code  


## 📂 Folder Structure Overview

### 🛠 Project Structure
```
├── BaseClass/
│ └── BaseTest.cs # Global setup, teardown, and WebDriver init
│
├── Config/
│ ├── ConfigReader.cs # Loads config based on active environment
│ └── TestConfig.json # Environment & browser settings
│
├── Data/
│ ├── TestDataReader.cs # Loads test data JSON
│ └── TestData.json
│
├── Examples/
│
├── PageObjects/
│
├── Reports/
│ └── AutomationReport_*.html # ExtentReports HTML reports
│
├── Screenshots/ # Screenshots saved on test failure
│
├── Tests/
│ ├── LoginTest.cs
│ ├── OtherDetailsTest.cs
│ ├── PersonalDetailsTest.cs
│ └── ZTemp.cs
│
├── Utils/
│ └── ExtentReportManager.cs # Singleton ExtentReports manager

```
## 🔠 Naming Conventions

| Element          | Convention    | Example               |
|------------------|---------------|-----------------------|
| File Name        | PascalCase.cs | `LoginTest.cs`        |
| Folder Name      | PascalCase    | `PageObjects`         |
| Class Name       | PascalCase   | `AuthService`         |
| Method Name      | PascalCase   | `GetUserInfo()`       |
| Variable Name    | camelCase    | `userEmail`           |
| Property Name    | PascalCase   | `UserEmail`           |
| Constant Name    | PascalCase   | `MaxRetries`          |
| Boolean Name     | camelCase    | `isLoggedIn`          |
| Test Method Name | PascalCase   | `ShouldLoginSuccessfully()` |



## ⚙️ Configuration

### TestConfig.json

```json
{
  "Environment": "QA",
  "Browser": "chrome",
  "BaseUrl": "https://opensource-demo.orangehrmlive.com/web/index.php/auth/login",
  "UserName": "Admin",
  "Password": "admin123"
}

```

## 🗃️ Test Data

- `Data/TestData.json` stores structured test data in JSON format, enabling data-driven testing  
- `Data/TestDataReader.cs` reads and parses this JSON data for use across multiple test cases  
- Separating test data from test logic improves maintainability and allows easy updates without code changes  
- Supports running tests with different input sets by simply modifying the JSON file  


## 💡 Examples
The `Examples/` folder contains a comprehensive set of ready-to-run raw demo test cases demonstrating various Selenium actions using C#. These tests cover common workflows and UI interactions to help you get started quickly and understand practical usage of the each selenium actions.


## 📐 Page Object Pattern

The **Page Object Model (POM)** design pattern helps keep your test code clean and maintainable by separating page-specific UI interactions into dedicated classes under `PageObjects/`.  
Each page class encapsulates element locators and actions, enabling reusable, readable, and easy-to-update test scripts. This reduces duplication and improves test stability.  

> 🛑 Deprecated in 3.11 (Nov 2017)  **❌ Note on PageFactory and `@FindBy`:** 
> While PageFactory with `@FindBy` annotations was popular for element initialization, it has known drawbacks:  
> - ⚠️ **Stale element references** can occur if the page reloads or elements change dynamically  
> - 🐢 Can introduce **performance overhead** due to proxy creation and lazy loading  
> - 🔧 Debugging issues can be harder when locators fail silently  
> - 📉 Less flexible for dynamic element handling compared to explicit waits or direct `FindElement` calls  
>
> Because of these issues, many prefer explicit element locating within methods combined with robust **explicit waits** (like those in the BC.Selenium.WebUI wrapper) instead of PageFactory.

Example benefits of the POM approach (without PageFactory):  
 **✅ Key benefits of the POM approach:**  
- 🧩 **Clear separation** of page structure and test logic for better readability  
- 🔄 **Reusable and maintainable** page methods to avoid duplication  
- 🛠️ **Enhanced control** over element locating and wait strategies for improved stability  
- 🧩 **Encapsulation** of UI elements and behaviors within page classes  
- 🔄 **Reusability** across multiple tests promoting DRY principles  
- 🛠️ **Simplified maintenance** when UI changes occur, minimizing test breakage  

## 📸 Screenshot on Failure
- Screenshots are saved under `/Screenshots/` with a timestamped filename.
- Automatically captured during `[TearDown]` if test fails.

## ▶️ Running Tests
You can run the tests using Visual Studio Test Explorer or via CLI:
```bash
dotnet test --filter "FullyQualifiedName~Tests"
```
- This runs tests in the Tests folder.
- You can also override config via environment variables or by editing TestConfig.json


## 📊 Reports

- 📂 HTML reports generated using ExtentReports, saved in `Reports/ as Report_CHROME_QA_DateTimeStamp.html`.
- 📋 Summary of test results with `pass/fail status, logs`, and linked failure `screenshots`.
- 🖥️ Includes key system/environment details like User Name, .NET version, NUnit version, run time, Git branch, machine info, environment, tester, OS, and browser.
- 🚀 Reports are automatically `published to GitHub Pages` on the gh-pages branch after each CI run—visit the site URL in `Settings → Pages → Visit site` to view the latest report live.
- 📦 After each run, the HTML report is `also available as a downloadable` artifact named html-report in the GitHub Actions workflow.


## 🛠️ Utils

- Contains utility classes and helpers to support test execution and reporting  
- `Utils/ExtentReportManager.cs` manages the **ExtentReports** lifecycle as a singleton, ensuring consistent and thread-safe report generation  
- Facilitates detailed logging, test categorization, and report customization  
- Helps keep test code clean by centralizing common reusable functions and setup tasks  

## ✍️📝 Commit Message Conventions

To keep commit history clean, consistent, and easy to understand, please follow the **Conventional Commit** types below when writing commit messages.

## Common Commit Types

| Type     | When to Use                                                   |
|----------|---------------------------------------------------------------|
| **feat** | A new feature                                                 |
| **fix**  | A bug fix                                                    |
| **docs** | Documentation-only changes                                   |
| **style**| Code style changes (formatting, missing semi-colons, etc.) — no logic change |
| **refactor** | Code changes that neither fixes a bug nor adds a feature |
| **perf** | Performance improvements                                    |
| **test** | Adding or updating tests                                    |
| **chore**| Changes to build process, auxiliary tools, libraries, or maintenance (no production code) |

### Examples for Your Project

| Type     | Example Commit Message                                     |
|----------|------------------------------------------------------------|
| feat     | `feat(login): add remember me checkbox`                    |
| fix      | `fix(cart): correct item quantity calculation`             |
| docs     | `docs(readme): update installation instructions`           |
| style    | `style: fix indentation and spacing`                       |
| refactor | `refactor: simplify login validation logic`                |
| perf     | `perf: improve page load time by optimizing queries`       |
| test     | `test: add unit tests for order service`                    |
| chore    | `chore: add environment info to extent report`             |

### Guidance for This Project
- Use **`chore:`** for infrastructure, configuration, tooling, or housekeeping tasks (e.g., adding environment info to Extent reports).  
- Use **`docs:`** when updating documentation like README files.  
- Use **`feat:`** for adding new test cases or reporting features.  
- Use **`fix:`** to correct bugs in tests or automation code.  

### Git Commit Message Format
```
A. <type>(<scope>): <short summary>
        or
B. <type>: <short summary>
        or
C. <type>: <short summary>
- Detail 1
- Detail 2
- Detail 3
```

- **`<type>`**: One of the commit types listed above.  
- **`<scope>`**: The area of the codebase affected (optional but recommended).  
- **`<short summary>`**: A concise description of the change.  

> NOTE: Keeping commit messages consistent helps everyone understand the project history and makes generating changelogs and releases easier.


## 📦 NuGet Packages Used
- AutoltX.Dotnet (3.3.14.5)
- BC.WeblJlWrapper (0.0.2-alpha)
- ⚠️ DotNetSeleniumExtras.WaitHelpers (3.11.0) => `(Provides ExpectedConditions class for WebDriverWait, last updated 3/11/2018) Deprecated in 3.11 (Nov 2017)`
- ❌ DotNetSeleniumExtras.PageObjects (3.11.0) => `(provides PageFactory (@FindBy) for .NET last updated 3/11/2018) Deprecated in 3.11 (Nov 2017)`
- ExtentReports (5.0.4)
- Microsoft.NET.Test.Sdk (17.14.1)
- Microsoft.Office.lnterop.Excel (15.0.4795.1001)
- Newtonsoft.Json (13.0.3)
- NUnit (4.3.2)
- NUnit3TestAdapter (5.0.0)
- Selenium.Support (4.34.0) ()
- Selenium.WebDriver (4.34.0)
- WebDriverManager (2.17.6)

## Explicit Waiting Strategies
When automating with Selenium WebDriver in C#, waiting for elements or conditions is crucial for stable tests. There are `three common approaches` you might see or use, especially with Selenium 4.34.0:

### ❌ 1. Old (Obsolete) — `ExpectedConditions` from Selenium.Support (pre-4.x)

```csharp
// 🚫 Deprecated and removed in Selenium 4.x — this code will NOT compile or run
WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10));
wait.Until(ExpectedConditions.ElementIsVisible(By.Id("username")));
```

### ⚠️ 2. Usage with DotNetSeleniumExtras.WaitHelpers
- 🕰️ Old / Legacy — last release was in 2018
- ⚠️ No longer actively maintained or supported by Selenium. Use alternatives for new projects.
- Minimal code change, requires NuGet using SeleniumExtras.WaitHelpers;
- Drop-in replacement, requires adding the DotNetSeleniumExtras.WaitHelpers NuGet package using SeleniumExtras.WaitHelpers;
```csharp
using SeleniumExtras.WaitHelpers; // Make sure to install DotNetSeleniumExtras.WaitHelpers
WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10));
IWebElement el = wait.Until(ExpectedConditions.ElementToBeClickable(By.Id("username")));
```

### ✅ 3. Usage with Pure Lambda (Built into Selenium.Support) — No Extra Packages Needed
 Best No external dependency — you stick to pure Selenium Lambda - Future-proof, no NuGet, more control
```csharp
WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10));
IWebElement el = wait.Until(d => {
    var element = d.FindElement(By.Id("username"));
    return (element.Displayed && element.Enabled) ? element : null;
});
```

## 👥 Author
Bijay Chhetri
🔗 github.com/bija510

## 📄 License
This project is licensed under the [MIT License](LICENSE).

